# test suite for Ghilbert verifier
# To run with the python verifier, run "python verify_test.py testsuite"

# low level syntactic stuff
!append test.gh
)
!reject test.gh Unbalanced parenthesis
!append test.gh
()
!reject test.gh List-valued command
!append test.gh
(kind wff)
!reject test.gh List-valued command

# Empty proof file is valid, if not very interesting
!append test.gh
!accept test.gh

!shared
!append test.ghi
!append test.gh
import (TEST test.ghi () "")
!end
!accept test.gh

!append test.ghi
kind
!reject test.gh kind cmd with no args

!append test.ghi
kind foo
!reject test.gh kinds must be in list

!append test.ghi
kind ()
!reject test.gh reject zero kinds

!append test.ghi
kind (bar baz)
!reject test.gh reject more than one kind

!append test.ghi
(kind wff)
!reject test.gh List-valued command in interface

!append test.ghi
kind ((wff))
!reject test.gh Kind must be string

!unshare

!shared
!append test.ghi
kind (wff)
kind (nat)
tvar (wff ph ps)
tvar (nat A B)
var (nat x y)
term (wff (= A B))
term (wff (-> ph ps))
term (wff (A. x ph))
term (nat (0))

stmt (19.21ai ((ph x)) ((-> ph ps)) (-> ph (A. x ps)))
stmt (ax-7 () () (-> (A. x (A. y ph)) (A. y (A. x ph))))
!append test.gh
import (TEST test.ghi () "")

tvar (wff ph ps)
var (nat x y)
tvar (nat A B)
!end
!accept test.gh

!append test.ghi
kind (wff)
!reject test.gh Redefinition of kind

!append test.gh
var (wff x)
!reject test.gh Symbol x already defined

# thm stuff

!append test.gh
# simple theorem that should check
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!accept test.gh

!append test.gh
thm (19.21ai ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Redefinition of thm label

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp 19.21ai)
!reject test.gh Not enough mand hyps

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x ph 19.21ai)
!reject test.gh Too many mand hyps

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. ph ps)) hyp ph 19.21ai)
!reject test.gh Mand hyp has wrong kind

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. A ps)) hyp A 19.21ai)
!reject test.gh Mand hyp has right kind, but tvar instead of binding var

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. A ps)) hyp (0) 19.21ai)
!reject test.gh Mand hyp has right kind, but term instead of binding var

!append test.gh
thm (19.21ai2 () (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Missing free var condition

# This one might be too strict
!append test.gh
thm (19.21ai2 ((ph x y)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Spurious free var condition

!append test.gh
thm (19.21ai2 (()) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 (ph) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 (((ph) x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 ((ph (x))) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

# This one might be too strict
!append test.gh
thm (19.21ai2 ((x ph)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Wrong order in free var clause

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Arity error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Arity error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph A)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Kind error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp ph) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Unification error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (A. x ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Unification error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) x 19.21ai)
!reject test.gh Stack underflow

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp hyp x 19.21ai)
!reject test.gh Too many terms on stack

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai x)
!reject test.gh Leftover mand hyp on stack

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ph)) hyp x 19.21ai)
!reject test.gh Stack doesn't match concl

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph baz)) (-> ph (A. x baz)) hyp x 19.21ai)
!reject test.gh Variable in hyp doesn't exist

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps) hyp2 baz) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Variable in hyp doesn't exist

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) (hyp x 19.21ai))
!reject test.gh Extra parens around proof - poorly formed

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)))
!reject test.gh Missing parts of thm

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)))
!reject test.gh Missing parts of thm

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) ((->) ph ps))
!reject test.gh Malformed term in proof step

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) (() ph ps))
!reject test.gh Malformed term in proof step

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) ())
!reject test.gh Malformed term in proof step

!append test.gh
thm (ax-7_2 () () (-> (A. x (A. y ph)) (A. y (A. x ph))) x y ph ax-7)
!accept test.gh

!append test.gh
thm (ax-7_2 () () (-> (A. x (A. x ph)) (A. x (A. x ph))) x x ph ax-7)
!reject test.gh Binding variables not distinct

!unshare

# Test malformed term cmd in export context
!shared
!append out.ghi
kind (wff)
kind (nat)
var (wff ph)
var (nat x y z)
tvar (nat A B)
stmt (foo () (ph) ph)
!append in.ghi
kind (wff)
kind (nat)
tvar (nat A B)
var (nat x y z)
term (wff (foo A))
term (wff (bar A B x) (x A))
!append test.gh
import (IN in.ghi () "")
var (wff ph)
var (nat x)
thm  (foo () (h ph) ph h)
export (OUT out.ghi () "")
!end
!accept test.gh

!append out.ghi
term BAD
!reject test.gh Expected 'term (KIND (NAME ARGVAR ...) (BARGVAR TARGVAR ...) ...'
!append out.ghi
term (BAD)
!reject test.gh Expected 'term (KIND (NAME ARGVAR ...) (BARGVAR TARGVAR ...) ...'
!append out.ghi
term (wff (unk))
!reject test.gh No term of name unk exists in verify context.
!append out.ghi
term (nat (foo))
!reject test.gh Result kind mismatch with verify context for foo
!append out.ghi
term (wff (foo ph))
!reject test.gh Term signature mismatch with verify context for foo
!append out.ghi
term (wff (foo x))
!reject test.gh binding/non-binding mismatch for term foo argument 0
!append out.ghi
term (wff (bar A B x))
!reject test.gh freemap mismatch for term bar
!append out.ghi
term (wff (bar A B x) (x B))
!reject test.gh freemap mismatch for term bar
!append out.ghi
term (wff (bar A B x) (x A))
!accept test.gh correctly export term with freemap

!unshare 

!shared
!append test.ghi
kind (wff)
kind (wff2)
kind (nat)
tvar (wff ph ps ch)
tvar (nat A B)
var (nat x y z)
term (wff (= A B))
term (wff (-> ph ps))
term (wff (A. x ph))
term (nat (0))

stmt (19.21ai ((ph x)) ((-> ph ps)) (-> ph (A. x ps)))
stmt (ax-7 () () (-> (A. x (A. y ph)) (A. y (A. x ph))))

term (nat (+ A B))
stmt (alnfi ((ph x)) () (-> ph (A. x ph)))
stmt (syl () ((-> ph ps) (-> ps ch)) (-> ph ch))
term (wff (-. ph))
term (wff (<-> ph ps))
stmt (id () () (-> ph ph))
stmt (biid () () (<-> ph ph))
stmt (preandi () (ph ps) (-. (-> ph (-. ps))))
!append test.gh
import (TEST test.ghi () "")

var (wff bph bps)
tvar (wff ph ps)
var (nat x y z)
tvar (nat A B)

!append out.ghi
kind (wff)
kind (wff2)
kind (nat)
var (nat x y z)
tvar (nat A B C)
tvar (wff ph ps)
tvar (wff2 ph2 ps2)
term (wff (-> ph ps))
term (wff (<-> ph ps))
term (wff (A. x ph))
term (wff (-. ph))
!end
!accept test.gh

# test bad export
!append out.ghi
stmt (foo () (ph) ph)
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Conclusion mismatch for stmt foo:  ph vs (-> ph ph)
!append out.ghi
stmt (foo () (ph) BAD)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Unknown variableBAD

!append out.ghi
stmt (foo () (ph2) ph2)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh sort or kind mismatch for ph2

!append out.ghi
stmt (foo () ((-> ph ps)) (-> ph ps))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Non one-to-one variable mapping

!append out.ghi
stmt (foo () ((-> ph ph)) (-> ph ph))
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Hypothesis mismatch for stmt foo: (-> ph ph) vs ph

!append out.ghi
stmt (foo () (()) ())
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh The empty list () is not a valid term expression.

!append out.ghi
stmt (foo () ((())) (()))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh A term expression must start with a term symbol.

!append out.ghi
stmt (foo () ((BAD)) (BAD))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Unknown term BAD

!append out.ghi
stmt (foo () ((->)) (->))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Hypothesis mismatch for stmt foo: (->) vs (-> ph ph)

!append out.ghi
stmt (foo () ((<-> ph ph)) (<-> ph ph))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Hypothesis mismatch for stmt foo: (<-> ph ph) vs (-> ph ph)

!append out.ghi
stmt (foo () ((-> ph (-> ph ph))) (-> ph (-> ph ph)))
!append test.gh
thm (foo () (h (-> ph ph)) (-> ph ph) h)
export (OUT out.ghi () "")
!reject test.gh Hypothesis mismatch for stmt foo: (-> ph (-> ph ph)) vs (-> ph ph)

# Test for malformed export stmt commands
!append out.ghi
stmt bad
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'

!append out.ghi
stmt (bad)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'

!append out.ghi
stmt ((bad) () (ph) ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'

!append out.ghi
stmt (foo bad (ph) ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'

!append out.ghi
stmt (foo () bad ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'

!append out.ghi
stmt (foobar () (ph) ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh An assertion 'foobar' does not exist in verify context.

!append out.ghi
stmt (foo () (ph) ph)
!append test.gh
thm (foo () (h ph) (-> ph ph) ph id)
export (OUT out.ghi () "")
!reject test.gh Conclusion mismatch for stmt foo: ph vs (-> ph ph)

!append out.ghi
stmt (foo () (ph) ph)
!append test.gh
var (wff foo)
export (OUT out.ghi () "")
!reject test.gh The symbol 'foo' is not an assertion in verify context.

!append out.ghi
stmt (foo () (ph) ph)
stmt (foo () (ph) ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh An assertion 'foo' has already been exported.

!append out.ghi
stmt (foo () (ph ph) ph)
!append test.gh
thm (foo () (h ph) ph h)
export (OUT out.ghi () "")
!reject test.gh The exported assertion 'foo' has ph,ph hypotheses, while its original has 1

!append out.ghi
stmt (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!accept test.gh Correctly export fvlist

!append out.ghi
stmt (foo (BAD (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh Each free variable constraint context clause must be a list of at least two variables.

!append out.ghi
stmt (foo ((BAD) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh Each free variable constraint context clause must be a list of at least two variables.

!append out.ghi
stmt (foo (((BAD) x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh Free variable constraint clause list elements must be variables

!append out.ghi
stmt (foo ((BAD x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh Unknown variable BAD

!append out.ghi
stmt (foo ((A x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh The variable A does not occur in the statement hypotheses or conclusions

!append out.ghi
stmt (foo ((x ph) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh The first variable in a free variable constraint clause must be a term variable, and the remaining variables must be binding variables.

!append out.ghi
stmt (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps ps)))))
!append test.gh
thm  (foo ((ph x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps ps))))
     ph  x  alnfi
        ps  id
     preandi)
export (OUT out.ghi () "")
!reject test.gh Export context free variable constraint (ps x) is unnecessary.

!append out.ghi
stmt (foo ((ph x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps))))))
!append test.gh
thm  (foo ((ph x) (ps x)) () (-. (-> (-> ph (A. x ph)) (-. (-> ps (A. x ps)))))
     ph  x  alnfi
        ps  x  alnfi
     preandi)
export (OUT out.ghi () "")
!reject test.gh Missing free variable constraint (ps x)


!append test.gh
thm (bleep () () (-> ph ph) ph id
!reject test.gh eof inside sexp

!append test.ghi
term (badKind (bad ph))
!reject test.gh Term result kind must be a known kind

!append test.ghi
term (wff badSig)
!reject test.gh Term signature must be a list starting with term symbol

!append test.ghi
term (wff (-. ph))
!reject test.gh A term of name -. already exists.

!append test.ghi
term (wff (term badvar))
!reject test.gh Term formal argument badvar is not a known variable

!append test.ghi
term (wff (term ph ph))
!reject test.gh Repeated term formal argument ph

!append test.ghi
term (wff (term x ph) freespec)
!reject test.gh Each free variable map clause must be a list of at least two term argument variables

!append test.ghi
term (wff (term x ph) (x ph) freespec)
!reject test.gh Each free variable map clause must be a list of at least two term argument variables

!append test.ghi
term (wff (term x ph) ())
!reject test.gh Each free variable map clause must be a list of at least two term argument variables

!append test.ghi
term (wff (term x ph) (freespec))
!reject test.gh Each free variable map clause must be a list of at least two term argument variables

!append test.ghi
term (wff (term x ph) (() ph))
!reject test.gh Each free variable map clause must be a list of at least two term argument variables

!append test.ghi
term (wff (term x ph) (badvar ph))
!reject test.gh The first variable in a term free variable map clause must be a binding variable argument of the term

!append test.ghi
term (wff (term x ph) (ph x))
!reject test.gh The first variable in a term free variable map clause must be a binding variable argument of the term

!append test.ghi
term (wff (term x ph) (x ph) (x ph))
!reject test.gh More than one free variable map clause for binding variable x

!append test.ghi
term (wff (term x ph) (x badvar))
!reject test.gh Free variable map clause element is not a term formal argument: badvar

!append test.ghi
term (wff (term x ph) (x ph ph))
!reject test.gh Free variable map clause contains ph more than once.


# Tests of defthm
!append test.ghi
stmt (df-term-just ((ph y z)) ()
      (<-> (A. x (A. y ph)) (A. x (A. z ph))))
!append test.gh
defthm (df-term wff (term x ph) ((ph y)) ()
         (<-> (term x ph) (A. x (A. y ph)))
         x z ph y df-term-just)
!accept test.gh Test defthm with definition dummy var

!append test.ghi
stmt (df-term-just ((ph y z)) ()
      (<-> (A. x (A. y ph)) (A. x (A. z ph))))
!append test.gh
defthm (df-term wff (term x ph) ((ph y) (ph z)) ()
         (<-> (term x ph) (A. x (A. y (-> (= z z) ph))))
         x z ph y df-term-just)
!reject test.gh Definition dummy variable z is not a proof dummy variable

!append test.ghi
stmt (df-term-just ((ph y z)) ()
      (<-> (-> (= y y) (A. x (A. y ph)))
           (-> (= z z) (A. x (A. z ph)))))
!append test.gh
defthm (df-term wff (term x ph) ((ph y)) ()
         (<-> (term x ph) (-> (= y y) (A. x (A. y ph))))
         z x ph y df-term-just)
!reject test.gh Definition dummy variable z occurs free in (-> (= z z) (A. x (A. z ph)))

!append test.ghi
kind (nat2)
var (nat2 x2 y2 z2)
term (wff (A.2 x2 ph))
stmt (df-term-just ((ph y2 y2)) ()
      (<-> (-> ps (-> (= x x) (A. x (A.2 y2 ph))))
           (-> ps (-> (= x x) (A. x (A.2 y2 ph))))))
!append test.gh
var (nat2 x2 y2 z2)
defthm (df-term wff (term ps x y2 ph) ((ph y2)) ()
         (<-> (term ps x y2 ph) (-> ps (-> (= x x) (A. x (A.2 y2 ph)))))
         ps x y2 ph df-term-just)
!accept test.gh Defthm dummy freeness from distinct binding vars

!append test.gh
defthm (df-term wff (term x) () ()
         (<-> (term x) (= x x)))
!reject test.gh Expected at least 7 args to thm

!append test.gh
defthm (df-term wff (term x) () ()
         (-> (= x x) (= x x))
  (= x x) id
)
!reject test.gh Term being defined does not occur in conclusion.

!append test.gh
defthm (df-term1 wff (term x) () (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x x))
  hyp
)
!accept test.gh Test defthm with hypothesis
!append test.gh
defthm (df-term2 wff (term x) () (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x y))
  hyp
)
!reject test.gh defthm conclusion mismatch: y versus: x
!append test.gh
defthm (df-term3 wff (term ph) () (hyp (-> ph ph))
         (-> (term ph) ph)
  hyp
)
!reject test.gh defthm conclusion mismatch: expected term, found
!append test.gh
defthm (df-term wff (term x) () (hyp (-> (= x x) (A. x ph)))
         (-> (term x) (= x x))
  hyp
)
!reject test.gh defthm conclusion mismatch: expected (= x x) but found (A. x ph)
!append test.gh
defthm (df-term wff (term x) () (hyp (-> (= x x) (= x x)))
         (-> (term y) (= x x))
  hyp
)
!reject test.gh All uses of the term being defined in the defthm conclusion must exactly match the definition term signature
!append test.gh
defthm (df-term wff (term A B) () (hyp (-> (= A B) (= B A)))
         (-> (term A B) (term A B))
  hyp
)
!reject test.gh All remnant subexpressions matching the definition term in the defthm conclusion must be identical.
!append test.gh
defthm (df-term wff (term A B) () (hyp (-> (= A A) (= A A)))
         (-> (term A B) (= A A))
  hyp
)
!reject test.gh Not all formal definition arguments occurred in definiens.
!append test.gh
defthm ((bad) wff (term x) () (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x x))
  hyp
)
!reject test.gh Expected 'defthm (LABEL KIND (TNAME VAR ...) ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
defthm (df-term wff (term x) "bad" (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x x))
  hyp
)
!reject test.gh Expected 'defthm (LABEL KIND (TNAME VAR ...) ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
defthm (df-term wff (term x) () bad
         (-> (term x) (= x x))
  hyp
)
!reject test.gh Expected 'defthm (LABEL KIND (TNAME VAR ...) ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
defthm (df-term (bad) (term x) () (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x x))
  hyp
)
!reject test.gh Expected 'defthm (LABEL KIND (TNAME VAR ...) ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
defthm (df-term wff bad () (hyp (-> (= x x) (= x x)))
         (-> (term x) (= x x))
  hyp
)
!reject test.gh Expected 'defthm (LABEL KIND (TNAME VAR ...) ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'

# Tests of bad/malformed proofs

!append test.gh
thm ((bad) () (hyp (-> (= x x) (= x x)))
         (-> (= x x) (= x x))
  hyp
)
!reject test.gh Expected 'thm (LABEL ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
thm (theorem bad (hyp (-> (= x x) (= x x)))
         (-> (= x x) (= x x))
  hyp
)
!reject test.gh Expected 'thm (LABEL ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
thm (theorem () bad
         (-> (= x x) (= x x))
  (= x x) id
)
!reject test.gh Expected 'thm (LABEL ((TVAR BVAR BVAR ...)) ({HYPNAME HYP} ...) CONCL STEP STEP ...)'
!append test.gh
thm (theorem () (odd)
         (-> (= x x) (= x x))
  (= x x) id
)
!reject test.gh hypothesis list must be of even length
!append test.gh
thm (theorem () ((odd) (= A A))
         (-> (= x x) (= x x))
  (= x x) id
)
!reject test.gh Hyp label must be string
!append test.gh
thm (theorem () (hyp (= A A) hyp (= A A))
         (-> (= x x) (= x x))
  (= x x) id
)
!reject test.gh Repeated hypothesis label hyp
!append test.gh
thm (theorem ((A x)) ()
         (-> (= A x) (= A x))
  (= A x) id
)
!reject test.gh Extra free variable constraint context pairs:  (A x)
!append test.gh
thm (theorem () ()
         (-> (= A x) (A. x (= A x)))
  (= A x)  x  alnfi
)
!reject test.gh Expected x not free in (= A x)

!append test.gh
thm (theorem () (hyp (-> (= A A) (= A A)))
         (-> (= x x) (= x x))
  x hyp
)
!reject test.gh Hyp expected no mand hyps, got 1
!append test.gh
thm (thm1 () ()
         (-> ph ph)
  ph id
)
thm (thm2 () ()
         (-> ph ph)
  ph thm1
)
!accept test.gh One theorem depends on another
!append test.gh
thm (thm1 () (h ph)
         (-> (-> ps ph) (-> ps ph))
  (-> ps ph) id
)
thm (thm2 () ()
         (-> ph ph)
  x thm1
)
!reject test.gh Kind mismatch for ps: expected wff but found x which is a nat

!append test.gh
thm (thm1 () (h bph)
         (-> bph bph)
  bph id
)
thm (thm2 () (h (-> ph ph))
         (-> (A. x ph) (A. x ph))
  (A. x ph) id
)
thm (thm3 () ()
         (-> (-> (A. x ph) (A. x ph))
             (-> (A. x ph) (A. x ph)))
  ph id
  x thm2
  thm1
)
!reject test.gh  Expected binding variable for bph

!append test.gh
thm (thm1 () (h bph)
         (-> ph ph)
  ph id
)
thm (thm3 () (h ph)
         (-> ph ph)
  h
  ph  thm1
)
!reject test.gh Expected binding variable for bph; ph is term variable

!append test.gh
thm (thm1 () (h1 bph  h2 bps)
         (-> ph ph)
  ph id
)
thm (thm3 () (h bps)
         (-> ph ph)
  h
  h
  ph  thm1
)
!reject test.gh Binding variables bph and bps both map to bps

!append test.gh
thm (thm1 () (h1 (-> ph ph))
         (-> ph ph)
  h1
)
thm (thm3 () (h (-> ph ps))
         (-> ph ph)
  h
  thm1
)
!reject test.gh Unification error: 1 expected φ got ψ

!append test.gh
thm (thm1 () (h1 (-> ph ph))
         (-> ph ph)
  h1
)
thm (thm3 () (h (-> ph ps))
         (-> ph ph)
  h
  thm1
)
!reject test.gh Unification error: 1 expected φ got ψ

!append test.gh
thm (thm1 () (h1 (-> ph ph))
         (-> ph ph)
  h1
)
thm (thm3 () (h (-> ph ph))
         (-> ph ph)
  h
  thm1
)
!accept test.gh Unification with repeated match


!append test.gh
thm (bleep () () (-> (A. x (A. (+ x y) ph)) (A. (+ x y) ph))
     x (A. (+ x y) ph) ax-4)
!reject test.gh Term expression substituted for term binding var argument

!append test.gh
thm (bleep2 () () (-> (A. x (A. B ph)) (A. B ph))
     x (A. B ph) ax-4)
!reject test.gh Term variable substituted for term binding var argument

!append test.gh
thm (bleep3 () () (-> ph ph)
     ph A alnfi)
!reject test.gh Term variable substituted for mandatory binding variable

!append test.gh
thm (bleep4 () () (-> ph ph)
     ph (+ x y) alnfi)
!reject test.gh Term expression substituted for mandatory binding variable

!append test.gh
defthm (df-an wff (/\ ph ps) () ()
          (-. (-> (-> (/\ ph ps) (-. (-> ph (-. ps))))
                  (-. (-> (-. (-> ph (-. ps))) (/\ ph ps)))))
        (-. (-> ph (-. ps))) id
        (-. (-> ph (-. ps))) id
        preandi)
!accept test.gh

!append test.gh
defthm (df-true wff (true) () () (true)
        ph id)
!reject test.gh Definition dummy is not binding variable

!append test.gh
defthm (df-eqvar wff (=var x y) () () (<-> (=var x y) (= x y))
  (= x y) biid
)
!reject test.gh Defined term has two binding variable arguments of the same kind

!unshare

!append in.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ p (→ q p)))
!append out.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ q (→ p q)))
!append test.gh
import (IN in.ghi () "")
tvar (formula p q)
export (OUT out.ghi () "")
!accept test.gh


# Tests of bad/malformed import
!append test.gh
import in.ghi
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import (IN in.ghi ())
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import ((IN) in.ghi () "")
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import (IN (in.ghi) () "")
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import (IN in.ghi "" "")
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import (IN in.ghi () ())
!reject test.gh Expected 'import (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.gh
import (IN in.ghi () a)
!reject test.gh prefix must be enclosed in quotes
!append test.gh
import (IN in.ghi () a")
!reject test.gh prefix must be enclosed in quotes
!append test.gh
import (IN in.ghi () "a)
!reject test.gh prefix must be enclosed in quotes
!append in.ghi
kind (formula)
!append test.gh
import (IN in.ghi () "")
import (IN test.ghi () "")
!reject test.gh An interface of name 'IN' already exists.


# Tests of importing with params
!shared 
!append in.ghi
param (TEST test.ghi () "")
kind (formula)
tvar (nat A B)
term (formula (= A B))
!append test.ghi
kind (nat)
!end
!append test.gh
import (TEST test.ghi () "")
import (IN in.ghi (TEST) "")
!accept test.gh
!append test.gh
import (TEST test.ghi () "")
import (IN in.ghi ((BAD)) "")
!reject test.gh import parameter must be an interface name
!append test.gh
import (TEST test.ghi () "")
import (IN in.ghi (BAD) "")
!reject test.gh Unknown interface BAD
!append test.gh
import (TEST test.ghi () "")
import (IN in.ghi (TEST TEST) "")
!reject test.gh Interface parameter TEST was repeated.

!append test2.ghi
kind (nat2)
!append test.gh
import (TEST test.ghi () "")
import (TEST2 test2.ghi () "")
import (IN in.ghi (TEST TEST2) "")
!reject test.gh Not all parameters passed to import interface IN were used.

!unshare

# Test malformed var commands
!append test.gh
var bad
!reject test.gh Expected 'var (KIND VAR ...)'
!append test.gh
var ()
!reject test.gh Expected 'var (KIND VAR ...)'
!append test.ghi
kind (wff)
!append test.gh
import (TEST test.ghi () "")
var (wff (bad))
!reject test.gh variable name must be an identifier.

# Test malformed var commands in interface
!shared
!append test.gh
import (TEST test.ghi () "")
!end
!append test.ghi
var bad
!reject test.gh Expected 'var (KIND VAR ...)'
!append test.ghi
var ()
!reject test.gh Expected 'var (KIND VAR ...)'
!append test.ghi
kind (wff)
var (wff (bad))
!reject test.gh variable name must be atom.
!append test.ghi
kind (wff)
var (wff repeat)
var (wff repeat)
!reject test.gh Variable repeat already defined

# Test bad/malformed param commands
!append test.ghi
param bad
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param ()
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param ((PARAM) param.ghi () "")
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param (PARAM (param.ghi) () "")
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param (PARAM param.ghi "" "")
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param (PARAM param.ghi () ())
!reject test.gh Expected 'param (IFNAME URL (IFNAME ...) "PREFIX")'
!append test.ghi
param (PARAM param.ghi () a)
!reject test.gh param prefix must be enclosed in quotes
!append test.ghi
param (PARAM param.ghi () a")
!reject test.gh param prefix must be enclosed in quotes
!append test.ghi
param (PARAM param.ghi () "a)
!reject test.gh param prefix must be enclosed in quotes
!append test.ghi
param (PARAM param.ghi () "")
!append test.gh
import (TEST test.ghi () "")
!reject test.gh More param commands than provided parameter interfaces

!append test.ghi
kind (wff)
!append test.gh
export (OUT out.ghi (TEST) "")
!append out.ghi
param (IN test.ghi () "")
!accept test.gh correctly export with param
!unshare

!append one.ghi
kind (foo)
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi () "")  # bad
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONE TWO) "")
!reject test.gh param interface 'TWO' requires 0 parameters.

!append one.ghi
kind (foo)
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (ONE two.ghi (ONE) "")  # bad
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONE TWO) "")
!reject test.gh The interface 'ONE' has already been used.

!append one.ghi
kind (foo)
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi (BAD) "")  # bad
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONE TWO) "")
!reject test.gh Unknown interface name BAD


!append one.ghi
kind (foo)
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi ((ONE)) "")  # bad
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONE TWO) "")
!reject test.gh Parameters to param must be interface names.

!append one.ghi
kind (foo)
!append one-alt.ghi
kind (bar)
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi (ONE) "")
!append test.gh
import (ONE one.ghi () "")
import (ONEALT one-alt.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONEALT TWO) "")
!reject test.gh Inconsistent parametrization of interface TWO

!append one.ghi
kind (foo)
!append two.ghi
kind (foo)
param (ONE one.ghi () "")
!append test.gh
import (ONE one.ghi () "one")
import (TWO two.ghi (ONE) "two")
!reject test.gh A kind foo already exists in import context.

!append one.ghi
kind (foo)
!append two.ghi
param (ONE one.ghi () "")
term (foo (mkfoo))
!append twoalt.ghi
param (ONE one.ghi () "")
term (foo (mkfoo))
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi (ONE) "")
param (TWOALT twoalt.ghi (ONE) "")
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (TWOALT twoalt.ghi (ONE) "alt")
import (THREE three.ghi (ONE TWO TWOALT) "")
!reject test.gh A term symbol mkfoo already exists in import context.

!append one.ghi
kind (foo)
term (foo (mkfoo))
!append two.ghi
param (ONE one.ghi () "")
!append three.ghi
param (ONE one.ghi () "")
param (TWO two.ghi (ONE) "")
!append test.gh
import (ONE one.ghi () "")
import (TWO two.ghi (ONE) "")
import (THREE three.ghi (ONE TWO) "")
!accept test.gh Correct nesting of parameters


# Tests of name prefixing on import
!shared
!append in.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ p (→ q p)))
!end
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (foo.→ p (foo.→ q p)) p q foo.AntecedentIntroduction)
!accept test.gh
!append test.gh
import (IN in.ghi () "foo.")
tvar (formula p q)
!reject test.gh Kind not known: formula
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (→ p (foo.→ q p)) p q foo.AntecedentIntroduction)
!reject test.gh term → not known
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (p p (foo.→ q p)) p q foo.AntecedentIntroduction)
!reject test.gh p is a variable not a operator. Operators always come before variables.
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (foo.→ p (foo.→ q p)) p q AntecedentIntroduction)
!reject test.gh unknown proof step: AntecedentIntroduction

# kindbind in proof modules
!shared
!append kinds.ghi
kind (formula)
kind (natural)
tvar (formula p r)
tvar (natural n k)
term (formula (→ p r))
term (natural (+ n k))
stmt (repeat () (p) p)
stmt (id () () (→ p p))
!append test.gh
import (IN kinds.ghi () "")
!end

!append test.gh
kindbind (formula wff)
!accept test.gh
!append test.gh
kindbind (foobar wff)
!reject test.gh Kind not known: foobar
!append test.gh
kindbind (formula natural)
!reject test.gh Kind nat already defined

!append test.gh
kindbind bad
!reject test.gh Expected 'kindbind (OLDKIND NEWKIND)'
!append test.gh
kindbind (formula)
!reject test.gh Expected 'kindbind (OLDKIND NEWKIND)'
!append test.gh
kindbind ((formula) natural)
!reject test.gh Expected 'kindbind (OLDKIND NEWKIND)'
!append test.gh
kindbind (formula (natural))
!reject test.gh Expected 'kindbind (OLDKIND NEWKIND)'

!append test.gh
term (formula (foo))
!reject test.gh Interface file command encountered in proof file.
!append test.gh
kind (formula)
!reject test.gh Interface file command encountered in proof file.
!append test.gh
param (TEST test.ghi () "")
!reject test.gh Interface file command encountered in proof file.



# can use a variable where one of another (bound) kind is expected
!append test.gh
kindbind (formula wff)
tvar (wff q)
thm (repeat2 () (H q) q
  H
  repeat)
!accept test.gh
# Here's a kind-checking test
!append test.gh
kindbind (formula wff)
kindbind (natural nat)
tvar (nat n)
thm (repeat2 () (H n) n
  H
  repeat)
!reject test.gh kind mismatch: n wanted formula found nat
# Similar, but with a term which is not just a variable
!append test.gh
kindbind (natural nat)
tvar (nat i j)
thm (repeat2 () (H (+ i j)) (+ i j)
  H
  repeat)
!reject test.gh kind mismatch: (+ i j) wanted formula found nat
# cannot use a variable declared with kindbound kind for another kind
!append test.gh
kindbind (natural nat)
tvar (nat n)
thm (repeat2 () (H n) n
  H
  repeat)
!reject test.gh kind mismatch: n wanted formula found natural [repeat]

# similar for mandatory hypotheses: first, able to use kindbound kind
!append test.gh
kindbind (formula wff)
tvar (wff q)
thm (id2 () () (→ q q)
  q id
)
!accept test.gh
# Here's a kind-checking test
!append test.gh
kindbind (formula wff)
kindbind (natural nat)
tvar (nat n)
thm (id2 () () (→ n n)
  n id
)
!reject test.gh
# cannot use a variable declared with kindbound kind for another kind
!append test.gh
kindbind (natural nat)
tvar (nat n)
thm (id2 () () (→ n n)
  n id
)
!reject test.gh

# Should be able to export to an interface which uses the kindbound kinds for result kinds
!append kinds_kindbound.ghi
kind (formula)
term (formula (⊤))
stmt (Truth () () (⊤))
!append out_kindbound.ghi
kind (wff)
term (wff (⊤))
stmt (Truth () () (⊤))
!append test_kindbound.gh
import (IN kinds_kindbound.ghi () "")
kindbind (formula wff)
export (OUT_EXPORTING_KINDBOUND out_kindbound.ghi () "")
!accept test_kindbound.gh

# cannot export to an interface with the wrong kinds
!append out.ghi
kind (wff)
kind (nat)
tvar (wff p r)
tvar (nat n k)
term (nat (→ p r))
!append test.gh
kindbind (formula wff)
kindbind (natural nat)
export (OUT_WITH_KIND_MISMATCH out.ghi () "")
!reject test.gh Term → kind mismatch with verify context term →

# Should be able to export to an interface which uses the kindbound kinds for arguments
!append out.ghi
kind (wff)
kind (formula)
kind (nat)
tvar (formula formula-term)
tvar (wff wff-term1 wff-term2)
tvar (nat n k)
term (formula (→ wff-term1 wff-term2))
term (nat (+ n k))
#stmt (repeat () (p) p)
stmt (id () () (→ wff-term1 wff-term1))
!append test.gh
kindbind (formula wff)
kindbind (natural nat)
export (OUT_EXPORTING_KINDBOUND_ARG out.ghi () "")
!accept test.gh

# cannot export to an interface with the wrong kinds
!append out.ghi
kind (wff)
kind (formula)
kind (nat)
tvar (wff p r)
tvar (nat n k)
term (formula (→ n k))
stmt (id () () (→ n n))
!append test.gh
kindbind (formula wff)
kindbind (natural nat)
export (OUT_WITH_KIND_MISMATCH_ARG out.ghi () "")
!reject test.gh Term signature mismatch with verify context for →

# cannot export to an interface with the wrong argument count
!append in-argcount.ghi
kind (formula)
tvar (formula p q r)
term (formula (myterm p))
!append out-argcount.ghi
kind (formula)
tvar (formula p q r)
term (formula (myterm p q))
!append test-argcount.gh
import (IN_ARGCOUNT in-argcount.ghi () "")
export (OUT_ARGCOUNT out-argcount.ghi () "")
!reject test-argcount.gh Term signature mismatch with verify context for myterm; kinds being exported to: ['formula', 'formula']; kinds in verify context: ['formula']

# kindbind in interfaces
!shared
!append kinds.ghi
kind (formula)
kindbind (formula wff)
kind (natural)
kindbind (natural nat)
tvar (formula p r)
tvar (nat n k)
term (formula (→ p r))
term (nat (+ n k))
stmt (repeat () (p) p)
stmt (id () () (→ p p))
!append test.gh
import (IN kinds.ghi () "")
!end

#!accept test.gh
!reject test.gh kindbind is not (yet at least) allowed in interfaces

!append test.gh
tvar (wff q)
thm (repeat2 () (H q) q
  H
  repeat)
#!accept test.gh
!reject test.gh kindbind is not (yet at least) allowed in interfaces

# Similar, but with a term which is not just a variable
!append test.gh
kindbind (natural nat)
tvar (nat i j)
thm (repeat-ij () (H (+ i j)) (+ i j)
  H
  repeat)
!reject test.gh kind mismatch: (+ i j) wanted formula found nat

!append test.gh
tvar (nat n)
thm (repeat-n () (H n) n
  H
  repeat
)
!reject test.gh kind mismatch: n wanted formula found natural

!append kinds.ghi
kindbind (foobar foo)
!reject test.gh Kind not known: foobar

!append kinds.ghi
kindbind (formula natural)
!reject test.gh A kind natural is already visible in the current import export context

# similar for mandatory hypotheses: first, able to use kindbound kind
!append test.gh
tvar (wff q)
thm (id2 () () (→ q q)
  q id
)
#!accept test.gh
!reject test.gh kindbind is not (yet at least) allowed in interfaces

# Here's a kind-checking test
!append test.gh
tvar (nat n)
thm (id2 () () (→ n n)
  n id
)
!reject test.gh
# cannot use a variable declared with kindbound kind for another kind
!append test.gh
tvar (nat n)
thm (id2 () () (→ n n)
  n id
)
!reject test.gh

# export
# first test is fairly simple, just import a file and then export the same one
!append test.gh
export (OUT kinds.ghi () "")
#!accept test.gh
!reject test.gh kindbind is not (yet at least) allowed in interfaces

# attempt to export without defining a kindbound kind name
!append out.ghi
kind (formula)
kindbind (formula exportname)
!append test.gh
export (OUT out.ghi () "")
!reject test.gh kind not known: exportname

# attempt to export and kindbind to the wrong types
!append out.ghi
kind (formula)
kindbind (formula nat)
kind (natural)
kindbind (natural wff)
!append test.gh
export (OUT out.ghi () "")
!reject test.gh kind nat should be bound to formula but is bound to natural

# an export kind-checking test which does not involve kindbind
!unshare
!append out.ghi
kind (formula)
kind (foo)
tvar (formula p q)
term (formula (* p q))
!append in.ghi
kind (formula)
kind (foo)
tvar (foo p q)
term (foo (* p q))
!append test.gh
import (IN in.ghi () "")
export (OUT out.ghi () "")
!reject test.gh Term * is of kind foo but verify context term * is of kind formula

# test that terms consistently dereference kindbinds
!unshare
!append kinds.ghi
kind (formula)
kindbind (formula wff)
tvar (wff p q)
term (wff (→ p q))
stmt (repeat () (p) p)
stmt (id () () (→ p p))
!append test.gh
import (IN kinds.ghi () "")
export (OUT kinds.ghi () "")
#!accept test.gh
!reject test.gh kindbind is not (yet at least) allowed in interfaces

# export and freeness
!shared
!append in.ghi
kind (formula)
tvar (formula p q φ ψ)
term (formula (→ p q))
term (formula (↔ p q))
stmt (BiconditionalReflexivity () () (↔ p p))
kind (object)
var (object x y)
term (formula (∀ x φ))
!append test.gh
import (IN in.ghi () "")
!append out.ghi
kind (formula)
tvar (formula p q φ ψ)
kind (object)
var (object x y)
!end

!append out.ghi
term (formula (foo x φ))
!append test.gh
tvar (formula p q φ ψ)
var (object x y)
defthm (df-foo formula (foo x φ) () () (↔ (foo x φ) (→ φ (∀ x φ)))
        (→ φ (∀ x φ)) BiconditionalReflexivity
)
export (OUT out.ghi () "")
!reject test.gh Term freemap mismatch with verify context for foo

# Import a statement (with hypotheses), and then export it unchanged.
!unshare
!append in.ghi
kind (formula)
tvar (formula p)
stmt (foo () (p) p)
!append out.ghi
kind (formula)
tvar (formula φ)
stmt (foo () (φ) φ)
!append test.gh
import (IN in.ghi () "")
export (OUT out.ghi () "")
!accept test.gh

# Freemaps and terms
!shared
!append in.ghi
kind (formula)
tvar (formula p q φ)
term (formula (∧ p q))
term (formula (↔ p q))

kind (object)
tvar (object s t A B C)
var (object x y)

term (formula (∀ x φ))
stmt (ForAllReflexivity () () (↔ (∀ x φ) (∀ x φ)))

term (formula (subst s x φ) (x s))
term (formula (= s t))
stmt (SubstReflexivity () () (↔ (subst s x φ) (subst s x φ)))

term (object (separate x A φ) (x A))
stmt (SeparateReflexivity () () (= (separate x A φ) (separate x A φ)))
!append test.gh
import (IN in.ghi () "")
!end

!accept test.gh

!append in.ghi
stmt (bad () () (= (separate x BAD φ) (separate x φ φ)))
!reject test.gh Unknown variable BAD

!append in.ghi
stmt (bad () () ())
!reject test.gh () is not a valid term expression.

!append in.ghi
stmt (bad () () (()))
!reject test.gh Bad term symbol()

!append in.ghi
stmt (bad () () (BAD))
!reject test.gh Unknown term BAD

!append in.ghi
stmt (bad () () (= (= x x) (= x x)))
!reject test.gh Expected term of kind object, but found (= x x)

!append in.ghi
stmt (bad () () (= x))
!reject test.gh Expected 2 arguments for term =, but found (= x)

!append in.ghi
stmt (KindMismatchInInterface () () (= (separate x φ φ) (separate x φ φ)))
!reject test.gh kind mismatch: (separate x φ φ) wanted object found formula

!append in.ghi
stmt (ExpectedBindingGotTerm () () (= (separate A A φ) (separate A A φ)))
!reject test.gh Expected a binding variable, found term variable A

!append in.ghi
stmt (ExpectedBindingGotTerm () () (= (separate A A φ) (separate A A φ)))
!reject test.gh Expected a binding variable, found term variable A

# Tests for bad/malformed stmt command
!append in.ghi
stmt bad
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'
!append in.ghi
stmt (bad)
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'
!append in.ghi
stmt ((bad) () () (= x x))
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'
!append in.ghi
stmt (good bad () (= x x))
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'
!append in.ghi
stmt (good () bad (= x x))
!reject test.gh Expected 'stmt (LABEL ((TVAR BVAR ...) ...) (HYP ...) CONCL)'
!append in.ghi
stmt (good (bad) () (= x x))
!reject test.gh  Each free variable constraint context clause must be a list of at least two variables.
!append in.ghi
stmt (good ((bad)) () (= x x))
!reject test.gh Each free variable constraint context clause must be a list of at least two variables.
!append in.ghi
stmt (good (((bad) x)) () (= x x))
!reject test.gh Free variable constraint clause list elements must be variables
!append in.ghi
stmt (good ((bad x)) () (= x x))
!reject test.gh Unknown variable bad
!append in.ghi
stmt (good ((x ph)) () (= x x))
!reject test.gh The first variable in a free variable constraint clause must be a term variable, and the remaining variables must be binding variables.
!append in.ghi
stmt (good ((A x)) () (= x x))
!reject test.gh The variable A does not occur in the statement hypotheses or conclusions

# test malformed term comand
!append in.ghi
term bad
!reject test.gh Expected 'term (KIND (NAME ARGVAR ...) (BARGVAR TARGVAR ...) ...'
!append in.ghi
term (bad)
!reject test.gh Expected 'term (KIND (NAME ARGVAR ...) (BARGVAR TARGVAR ...) ...'

!unshare

# Attempt to apply a theorem which violates a freeness constraint
!append axioms.ghi
kind (formula)
tvar (formula p q φ)
term (formula (↔ p q))

kind (object)
tvar (object s t A B C)
var (object x y z)
term (formula (= s t))
term (object (1))

term (formula (∃ z φ))
stmt (ThereExistsAddRemove ((φ z)) () (↔ (∃ z φ) φ))
!append test.gh
import (AXIOMS axioms.ghi () "")
var (object z)
thm (bad () () (↔ (∃ z (= z (1))) (= z (1)))
 z (= z (1)) ThereExistsAddRemove
)
!reject test.gh Free variable constraint violation: Variable z occurs explicitly free in ['=', 'z', ['1']] [ThereExistsAddRemove]

