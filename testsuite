# test suite for Ghilbert verifier
# To run with the python verifier, run "python verify_test.py testsuite"

# low level syntactic stuff
!append test.gh
)
!reject test.gh Unbalanced parenthesis
!append test.gh
()
!reject test.gh List-valued command
!append test.gh
(kind wff)
!reject test.gh List-valued command

# Empty proof file is valid, if not very interesting
!append test.gh
!accept test.gh

!shared
!append test.ghi
!append test.gh
import (TEST test.ghi () "")
!end
!accept test.gh

!append test.ghi
kind
!reject test.gh kind cmd with no args

!append test.ghi
kind foo
!reject test.gh kinds must be in list

!append test.ghi
kind ()
!reject test.gh reject zero kinds

!append test.ghi
kind (bar baz)
!reject test.gh reject more than one kind

!append test.ghi
(kind wff)
!reject test.gh List-valued command in interface

!unshare

!shared
!append test.ghi
kind (wff)
kind (nat)
tvar (wff ph ps)
tvar (nat A B)
var (nat x y)
term (wff (= A B))
term (wff (-> ph ps))
term (wff (A. x ph))
term (nat (0))

stmt (19.21ai ((ph x)) ((-> ph ps)) (-> ph (A. x ps)))
stmt (ax-7 () () (-> (A. x (A. y ph)) (A. y (A. x ph))))
!append test.gh
import (TEST test.ghi () "")

tvar (wff ph ps)
var (nat x y)
tvar (nat A B)
!end
!accept test.gh

!append test.ghi
kind (wff)
!reject test.gh Redefinition of kind

# thm stuff

!append test.gh
# simple theorem that should check
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!accept test.gh

!append test.gh
thm (19.21ai ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Redefinition of thm label

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp 19.21ai)
!reject test.gh Not enough mand hyps

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x ph 19.21ai)
!reject test.gh Too many mand hyps

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. ph ps)) hyp ph 19.21ai)
!reject test.gh Mand hyp has wrong kind

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. A ps)) hyp A 19.21ai)
!reject test.gh Mand hyp has right kind, but tvar instead of binding var

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. A ps)) hyp (0) 19.21ai)
!reject test.gh Mand hyp has right kind, but term instead of binding var

!append test.gh
thm (19.21ai2 () (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Missing free var condition

# This one might be too strict
!append test.gh
thm (19.21ai2 ((ph x y)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Spurious free var condition

!append test.gh
thm (19.21ai2 (()) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 (ph) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 (((ph) x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

!append test.gh
thm (19.21ai2 ((ph (x))) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Malformed free var clause

# This one might be too strict
!append test.gh
thm (19.21ai2 ((x ph)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Wrong order in free var clause

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Arity error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Arity error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph A)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Kind error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp ph) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Unification error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (A. x ph)) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Unification error in hyp

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) x 19.21ai)
!reject test.gh Stack underflow

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp hyp x 19.21ai)
!reject test.gh Too many terms on stack

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) hyp x 19.21ai x)
!reject test.gh Leftover mand hyp on stack

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ph)) hyp x 19.21ai)
!reject test.gh Stack doesn't match concl

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph baz)) (-> ph (A. x baz)) hyp x 19.21ai)
!reject test.gh Variable in hyp doesn't exist

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps) hyp2 baz) (-> ph (A. x ps)) hyp x 19.21ai)
!reject test.gh Variable in hyp doesn't exist

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) (hyp x 19.21ai))
!reject test.gh Extra parens around proof - poorly formed

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)))
!reject test.gh Missing parts of thm

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)))
!reject test.gh Missing parts of thm

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) ((->) ph ps))
!reject test.gh Malformed term in proof step

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) (() ph ps))
!reject test.gh Malformed term in proof step

!append test.gh
thm (19.21ai2 ((ph x)) (hyp (-> ph ps)) (-> ph (A. x ps)) ())
!reject test.gh Malformed term in proof step

!append test.gh
thm (ax-7_2 () () (-> (A. x (A. y ph)) (A. y (A. x ph))) x y ph ax-7)
!accept test.gh

!append test.gh
thm (ax-7_2 () () (-> (A. x (A. x ph)) (A. x (A. x ph))) x x ph ax-7)
!reject test.gh Binding variables not distinct

!unshare

!shared
!append test.ghi
kind (wff)
kind (nat)
tvar (wff ph ps)
tvar (nat A B)
var (nat x y)
term (wff (= A B))
term (wff (-> ph ps))
term (wff (A. x ph))
term (nat (0))

stmt (19.21ai ((ph x)) ((-> ph ps)) (-> ph (A. x ps)))
stmt (ax-7 () () (-> (A. x (A. y ph)) (A. y (A. x ph))))

term (nat (+ A B))
stmt (alnfi ((ph x)) () (-> ph (A. x ph)))
term (wff (-. ph))
term (wff (<-> ph ps))
stmt (id () () (-> ph ph))
stmt (biid () () (<-> ph ph))
stmt (preandi () (ph ps) (-. (-> ph (-. ps))))
!append test.gh
import (TEST test.ghi () "")

tvar (wff ph ps)
var (nat x y)
tvar (nat A B)
!end
!accept test.gh

!append test.gh
thm (bleep () () (-> (A. x (A. (+ x y) ph)) (A. (+ x y) ph))
     x (A. (+ x y) ph) ax-4)
!reject test.gh Term expression substituted for term binding var argument

!append test.gh
thm (bleep2 () () (-> (A. x (A. B ph)) (A. B ph))
     x (A. B ph) ax-4)
!reject test.gh Term variable substituted for term binding var argument

!append test.gh
thm (bleep3 () () (-> ph ph)
     ph A alnfi)
!reject test.gh Term variable substituted for mandatory binding variable

!append test.gh
thm (bleep4 () () (-> ph ph)
     ph (+ x y) alnfi)
!reject test.gh Term expression substituted for mandatory binding variable

!append test.gh
defthm (df-an wff (/\ ph ps) () ()
          (-. (-> (-> (/\ ph ps) (-. (-> ph (-. ps))))
                  (-. (-> (-. (-> ph (-. ps))) (/\ ph ps)))))
        (-. (-> ph (-. ps))) id
        (-. (-> ph (-. ps))) id
        preandi)
!accept test.gh

!append test.gh
defthm (df-true wff (true) () () (true)
        ph id)
!reject test.gh Definition dummy is not binding variable

!append test.gh
defthm (df-eqvar wff (=var x y) () () (<-> (=var x y) (= x y))
  (= x y) biid
)
!reject test.gh Defined term has two binding variable arguments of the same kind

!unshare

!append in.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ p (→ q p)))
!append out.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ q (→ p q)))
!append test.gh
import (IN in.ghi () "")
tvar (formula p q)
export (OUT out.ghi () "")
!accept test.gh

# Tests of name prefixing on import
!shared
!append in.ghi
kind (formula)
tvar (formula p q)
term (formula (→ p q))
stmt (AntecedentIntroduction () () (→ p (→ q p)))
!end
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (foo.→ p (foo.→ q p)) p q foo.AntecedentIntroduction)
!accept test.gh
!append test.gh
import (IN in.ghi () "foo.")
tvar (formula p q)
!reject test.gh Kind not known: formula
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (→ p (foo.→ q p)) p q foo.AntecedentIntroduction)
!reject test.gh term → not known
!append test.gh
import (IN in.ghi () "foo.")
tvar (foo.formula p q)
thm (foo () () (foo.→ p (foo.→ q p)) p q AntecedentIntroduction)
!reject test.gh unknown proof step: AntecedentIntroduction

